<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Typing Effect Demo</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
    
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Inter', sans-serif;
      overflow: hidden;
    }
    
    .container {
      position: relative;
      height: 100vh;
      width: 100%;
      overflow: hidden;
    }
    
    .hero {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      background-color: #fff;
      color: #333;
      z-index: 1;
      transition: transform 0.5s ease;
    }
    
    .hero.hidden {
      transform: translateY(-100%);
    }
    
    .typing-container {
      font-size: 2rem;
      margin: 0 1rem;
      display: inline-block;
    }
    
    .typing-text {
      display: inline;
    }
    
    .cursor {
      display: inline-block;
      width: 1px;
      height: 1.3em;
      background-color: #333;
      margin-left: 0;
      vertical-align: text-bottom;
      position: relative;
      top: -3px;
      animation: blink 1s infinite;
    }
    
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }
    
    .arrow {
      position: absolute;
      bottom: 2rem;
      font-size: 1.5rem;
      cursor: pointer;
      z-index: 3;
      transition: opacity 0.3s ease;
    }
    
    .content {
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      height: 100%;
      background-color: #333;
      color: #fff;
      overflow-y: auto;
      transition: transform 0.5s ease;
    }
    
    .content.visible {
      transform: translateY(-100%);
    }
    
    .content-inner {
      max-width: 700px;
      margin: 0 auto;
      padding: 4rem 2rem;
    }
    
    .content h2 {
      font-size: 2.2rem;
      margin-bottom: 2rem;
      text-align: center;
      font-weight: 500;
    }
    
    .content p {
      margin-bottom: 1.5rem;
      font-size: 1.1rem;
      text-align: justify;
      text-indent: 1.5rem;
      hyphens: auto;
      font-weight: 300;
      line-height: 1.6;
    }
    
    .content p:first-of-type::first-letter {
      font-size: 3.5rem;
      float: left;
      line-height: 0.65;
      margin: 0.1em 0.1em 0 0;
      font-weight: 600;
    }
    
    .scroll-toggle {
      position: fixed;
      top: 15px;
      right: 15px;
      z-index: 100;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      cursor: pointer;
      transition: all 0.3s ease;
      opacity: 1;
    }
    
    .scroll-toggle:hover {
      background-color: rgba(255, 255, 255, 0.9);
    }
    
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
      margin-left: 8px;
    }
    
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: #2196F3;
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(20px);
    }
    
    .return-to-top {
      position: fixed;
      top: 15px;
      left: 15px;
      z-index: 100;
      background-color: rgba(255, 255, 255, 0.8);
      color: #333;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.9rem;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .return-to-top.visible {
      opacity: 1;
      pointer-events: auto;
    }
    
    @media (max-width: 600px) {
      .typing-container {
        font-size: 1.5rem;
      }
      
      .content-inner {
        padding: 3rem 1.5rem;
      }
      
      .scroll-toggle {
        display: none; /* Hide the toggle on mobile */
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="hero" id="hero">
      <div class="typing-container">
        <span class="typing-text" id="typing-text"></span><span class="cursor"></span>
      </div>
      <div class="arrow" id="arrow">↓</div>
    </div>
    
    <div class="content" id="content">
      <div class="content-inner">
        <h2>Lorem Ipsum</h2>
        <p>
          Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus lacinia odio vitae vestibulum vestibulum. Cras porttitor metus justo, vitae fringilla nibh blandit id. Duis auctor commodo libero, eu lacinia ipsum pulvinar vitae. Phasellus eget enim eu lectus faucibus vestibulum.
        </p>
        <p>
          Suspendisse sodales pellentesque elementum. Morbi fermentum dui sit amet libero iaculis, eget mollis velit vestibulum. Donec ut rhoncus orci. Sed vitae mauris sit amet risus consequat suscipit. Mauris varius nulla in justo tincidunt, ac commodo nunc feugiat.
        </p>
        <p>
          Vivamus laoreet nisl quis odio euismod, a condimentum lacus blandit. Nullam pulvinar mi eu diam molestie, in lacinia ligula consequat. Proin sagittis nulla sed mi lacinia, in tempor ante ultricies. Maecenas at diam sit amet justo convallis ullamcorper vel vitae purus.
        </p>
      </div>
    </div>
    
    <div class="scroll-toggle" id="scroll-toggle">
      <span>Invert Scroll</span>
      <label class="toggle-switch">
        <input type="checkbox" id="scroll-direction-toggle">
        <span class="toggle-slider"></span>
      </label>
    </div>
    
    <div class="return-to-top" id="return-to-top">
      ↑ Return to Top
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Elements
      const text = "The quick brown fox jumps over the lazy dog.";
      const typingText = document.getElementById('typing-text');
      const arrow = document.getElementById('arrow');
      const container = document.querySelector('.container');
      const hero = document.getElementById('hero');
      const content = document.getElementById('content');
      const scrollToggle = document.getElementById('scroll-direction-toggle');
      const returnToTop = document.getElementById('return-to-top');
      
      // Variables to track scroll detection
      let lastScrollTop = 0;
      let scrollUpAttempts = 0;
      
      // Track if content is visible
      let contentVisible = false;
      
      // Scroll direction preference - using memory instead of localStorage
      let invertScroll = false; // Default to standard scrolling
      scrollToggle.checked = invertScroll;
      
      // NEW: Variables for spring effect detection
      let isAtRest = true;
      let lastScrollTime = 0;
      let scrollRestThreshold = 250; // ms to consider scrolling "at rest"
      let buttonLockActive = false; // Prevents hiding during spring effects
      let lastUserInteraction = 0;
      let userInteractionThreshold = 100; // ms to consider a new user interaction
      let scrollEndTimeout;
      
      // NEW: Variables for delayed button showing
      let pendingButtonShow = null;
      let buttonDelay = 500; // 0.5 second delay before showing
      
      // Update scroll preference when changed
      scrollToggle.addEventListener('change', function() {
        invertScroll = this.checked;
      });
      
      // Typing animation
      let charIndex = 0;
      function typeWriter() {
        if (charIndex < text.length) {
          typingText.textContent += text.charAt(charIndex);
          charIndex++;
          setTimeout(typeWriter, 100);
        }
      }
      
      // Start typing
      typeWriter();
      
      // Handle arrow click - smoothly scroll to show content
      arrow.addEventListener('click', function() {
        if (!contentVisible) {
          showContent();
          
          // Ensure content is scrollable after transition
          setTimeout(() => {
            // Force a small scroll to ensure scrolling works
            content.scrollTo(0, 1);
            setTimeout(() => {
              // Then scroll back to top
              content.scrollTo(0, 0);
            }, 100);
          }, 600);
        }
      });
      
      // Return to top button click
      returnToTop.addEventListener('click', function() {
        showHero();
        // Reset all tracking variables
        returnToTop.classList.remove('visible');
        buttonLockActive = false;
        scrollUpAttempts = 0;
      });
      
      // Function to show content and hide hero
      function showContent() {
        hero.classList.add('hidden');
        content.classList.add('visible');
        contentVisible = true;
        
        // Make sure scrolling is enabled for content
        setTimeout(() => {
          document.body.style.overflow = 'auto';
          content.style.overflow = 'auto';
          
          // Force a small scroll to ensure scrolling works properly
          content.scrollTo(0, 1);
          setTimeout(() => {
            // Then scroll back to top (unless user has already scrolled)
            if (content.scrollTop <= 1) {
              content.scrollTo(0, 0);
            }
          }, 100);
        }, 500); // Match the transition duration
      }
      
      // Function to show hero and hide content
      function showHero() {
        hero.classList.remove('hidden');
        content.classList.remove('visible');
        contentVisible = false;
        returnToTop.classList.remove('visible');
        scrollUpAttempts = 0;
        buttonLockActive = false;
        
        // Clear any pending button show
        if (pendingButtonShow) {
          clearTimeout(pendingButtonShow);
          pendingButtonShow = null;
        }
        
        // Reset overflow settings
        document.body.style.overflow = 'hidden';
        
        // Scroll content back to top when returning to hero
        setTimeout(() => {
          content.scrollTop = 0;
        }, 500);
      }
      
      // Helper function to show return button with validation
      function scheduleButtonShow() {
        // Clear any existing pending show
        if (pendingButtonShow) {
          clearTimeout(pendingButtonShow);
        }
        
        // Schedule a new validation and show
        pendingButtonShow = setTimeout(() => {
          // Only show if we're still at the top of content
          if (content.scrollTop <= 3 && contentVisible) {
            returnToTop.classList.add('visible');
            buttonLockActive = true;
            lastUserInteraction = Date.now();
          }
          pendingButtonShow = null;
        }, buttonDelay);
      }
      
      // Device detection
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      
      if (isMobile) {
        // Automatically invert scrolling on mobile
        invertScroll = true;
        scrollToggle.checked = true;
      }
      
      // IMPROVED: Monitor content scroll with more fluid response
      content.addEventListener('scroll', function() {
        if (!contentVisible) return;
        
        const now = Date.now();
        const currentScrollTop = content.scrollTop;
        const timeSinceLastScroll = now - lastScrollTime;
        const scrollVelocity = Math.abs(currentScrollTop - lastScrollTop) / timeSinceLastScroll;
        
        // Determine if we're in a new scroll action or continuing momentum
        // Use a more forgiving threshold for mobile
        isAtRest = timeSinceLastScroll > (isMobile ? 150 : scrollRestThreshold);
        
        // At the top and trying to scroll up (may be spring effect or user action)
        if (currentScrollTop <= 3 && currentScrollTop < lastScrollTop) {
          // If there's a clear scroll attempt OR we appear to be at rest
          if (scrollUpAttempts === 0 || isAtRest || scrollVelocity > 0.2) {
            scrollUpAttempts++;
            
            // Schedule button to show if we have enough scroll attempts
            if ((isMobile && scrollUpAttempts >= 1) || scrollUpAttempts >= 2) {
              if (!returnToTop.classList.contains('visible') && !pendingButtonShow) {
                scheduleButtonShow();
              }
            }
          }
        } 
        // User is clearly scrolling down - respond immediately on mobile
        else if (currentScrollTop > (isMobile ? 20 : 50) && currentScrollTop > lastScrollTop) {
          // Cancel any pending button show
          if (pendingButtonShow) {
            clearTimeout(pendingButtonShow);
            pendingButtonShow = null;
          }
          
          // On mobile, respond more quickly to downward scrolls
          if (isMobile && scrollVelocity > 0.1) {
            returnToTop.classList.remove('visible');
            scrollUpAttempts = 0;
            buttonLockActive = false;
          }
          // On desktop, still use the smoother transition
          else if (isAtRest && now - lastUserInteraction > userInteractionThreshold && !buttonLockActive) {
            returnToTop.classList.remove('visible');
            scrollUpAttempts = 0;
          }
        }
        
        lastScrollTop = currentScrollTop;
        lastScrollTime = now;
        
        // Clear any existing timeout
        clearTimeout(scrollEndTimeout);
        
        // Set a new timeout to detect when scrolling truly ends
        // but make it faster on mobile
        scrollEndTimeout = setTimeout(() => {
          // If we've scrolled down, safely hide the button and reset lock
          if (content.scrollTop > (isMobile ? 20 : 50)) {
            returnToTop.classList.remove('visible');
            buttonLockActive = false;
            scrollUpAttempts = 0;
            
            // Also clear any pending button show
            if (pendingButtonShow) {
              clearTimeout(pendingButtonShow);
              pendingButtonShow = null;
            }
          }
        }, isMobile ? 150 : 300); // Quicker timeout on mobile
      });
      
      // PRESERVED: Handle wheel event for desktop
      window.addEventListener('wheel', function(e) {
        if (!contentVisible) {
          // If hero is visible and scrolling down, show content
          if (e.deltaY > 0) {
            e.preventDefault();
            showContent();
          }
        } else {
          // If content is visible and at the top
          if (content.scrollTop === 0 && e.deltaY < 0) {
            // Cancel any pending button show first
            if (pendingButtonShow) {
              clearTimeout(pendingButtonShow);
              pendingButtonShow = null;
            }
            
            // For a strong scroll gesture, return to hero immediately
            if (Math.abs(e.deltaY) > 50) {
              e.preventDefault();
              showHero();
              // Reset all tracking variables
              returnToTop.classList.remove('visible');
              buttonLockActive = false;
              scrollUpAttempts = 0;
            } else {
              // For gentle scroll gestures at the top, track attempts
              scrollUpAttempts++;
              if (scrollUpAttempts >= 2) {
                if (!returnToTop.classList.contains('visible') && !pendingButtonShow) {
                  scheduleButtonShow();
                }
              }
            }
          } else if (e.deltaY > 0 && !buttonLockActive) {
            // User is scrolling down and no lock is active, hide button
            // and cancel any pending shows
            if (pendingButtonShow) {
              clearTimeout(pendingButtonShow);
              pendingButtonShow = null;
            }
            returnToTop.classList.remove('visible');
            scrollUpAttempts = 0;
          }
        }
      }, { passive: false });
      
      // Touch support variables
      let touchStartY = 0;
      let touchEndY = 0;
      let touchStartTime = 0;
      
      // IMPROVED: Touch start - record starting position and time
      document.addEventListener('touchstart', function(e) {
        touchStartY = e.touches[0].clientY;
        touchStartTime = Date.now();
      }, { passive: true });
      
      // IMPROVED: Touch move handler with immediate transitions
      document.addEventListener('touchmove', function(e) {
        // Only intercept at boundaries when needed
        if (contentVisible && content.scrollTop <= 1) {
          const currentY = e.touches[0].clientY;
          const deltaY = currentY - touchStartY;
          const touchVelocity = deltaY / (Date.now() - touchStartTime);
          
          // If pulling down significantly at the top of content OR with high velocity
          if (deltaY > 40 || (deltaY > 20 && touchVelocity > 0.5)) {
            // Prevent default to avoid competing with normal scroll
            e.preventDefault();
            
            // Cancel any pending button show
            if (pendingButtonShow) {
              clearTimeout(pendingButtonShow);
              pendingButtonShow = null;
            }
            
            // For a strong or fast pull, immediately return to hero
            // without waiting for touchend
            showHero();
            
            // Reset all tracking variables
            returnToTop.classList.remove('visible');
            buttonLockActive = false;
            scrollUpAttempts = 0;
          } else if (deltaY > 10) {
            // Small pull-down attempt, show button but don't trigger transition yet
            // and only count if we're not already transitioning
            if (!hero.classList.contains('hidden')) {
              scrollUpAttempts++;
              if (scrollUpAttempts >= 1 && !returnToTop.classList.contains('visible') && !pendingButtonShow) {
                scheduleButtonShow();
              }
            }
          }
        } else if (content.scrollTop > 20) {
          // If we've scrolled down, cancel any pending button show
          if (pendingButtonShow) {
            clearTimeout(pendingButtonShow);
            pendingButtonShow = null;
          }
        }
        // Otherwise let normal scrolling work (passive scrolling)
      }, { passive: false });
      
      // IMPROVED: Touch end with immediate response
      document.addEventListener('touchend', function(e) {
        touchEndY = e.changedTouches[0].clientY;
        const touchDiff = touchStartY - touchEndY;
        const touchDuration = Date.now() - touchStartTime;
        const touchVelocity = Math.abs(touchDiff) / touchDuration;
        
        // If hero is visible and swiping up, show content immediately
        // Fast swipe needs less distance
        if (!contentVisible && (touchDiff > 50 || (touchDiff > 20 && touchVelocity > 0.5))) {
          showContent();
        }
        // If content is visible, at top, and swiping down
        else if (contentVisible && content.scrollTop <= 3 && touchDiff < -20) {
          // Transition might have already happened in touchmove
          // but handle case where it didn't
          if (content.classList.contains('visible')) {
            // For pull-down gestures, go to hero 
            // (we now use velocity to require less distance for fast swipes)
            if (Math.abs(touchDiff) > 60 || touchVelocity > 0.5) {
              // Cancel any pending button show
              if (pendingButtonShow) {
                clearTimeout(pendingButtonShow);
                pendingButtonShow = null;
              }
              
              showHero();
              // Reset all tracking variables
              returnToTop.classList.remove('visible');
              buttonLockActive = false;
              scrollUpAttempts = 0;
            }
            // For gentle pull-downs, schedule the button to show after validation
            else if (touchDuration > 100) {
              if (!returnToTop.classList.contains('visible') && !pendingButtonShow) {
                scheduleButtonShow();
              }
            }
          }
        } else if (touchDiff > 10 && content.scrollTop > 20) {
          // If we detect a swipe down and we're not at the top,
          // cancel any pending button show
          if (pendingButtonShow) {
            clearTimeout(pendingButtonShow);
            pendingButtonShow = null;
          }
        }
      });
      
      // Touch cancel handler
      document.addEventListener('touchcancel', function() {
        // For touch cancel, we treat it like any other validation
        // If we're at the top and there were attempts, schedule the button
        if (scrollUpAttempts >= 1 && content.scrollTop <= 5 && !returnToTop.classList.contains('visible') && !pendingButtonShow) {
          scheduleButtonShow();
        }
      });
    });
  </script>
</body>
</html>